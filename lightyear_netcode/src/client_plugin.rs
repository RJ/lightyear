use crate::auth::Authentication;
use crate::{ClientConfig, ClientState, Error};
use bevy::ecs::component::{ComponentHook, ComponentId, ComponentsRegistrator, HookContext, Mutable, RequiredComponents, StorageType};
use bevy::ecs::world::DeferredWorld;
use bevy::prelude::*;
use core::net::SocketAddr;
use lightyear_connection::client::{Connect, Connected, Connecting, Disconnect, Disconnected};
use lightyear_connection::id::PeerId;
use lightyear_connection::ConnectionSet;
use lightyear_link::{Link, LinkSet, SendPayload};
use lightyear_transport::plugin::TransportSet;
use lightyear_transport::prelude::Transport;
use tracing::{debug, error, info};

pub struct NetcodeClientPlugin;

/// Add this component on an entity to make it a netcode client.
///
/// The [`Link`] component will be added.
#[derive(Component)]
#[require(Link, lightyear_connection::client::Client)]
#[component(on_add = on_client_add)]
pub struct NetcodeClient {
    pub inner: crate::client::NetcodeClient<()>,
}

fn on_client_add(mut world: DeferredWorld, context: HookContext) {
    let server_addr = world.get::<NetcodeClient>(context.entity).map(|client| client.inner.server_addr());
    if let Some(mut link) = world.get_mut::<Link>(context.entity) {
        link.as_mut().remote_addr = server_addr;
    }
}

#[derive(Clone, Reflect)]
/// Config related to the netcode protocol (abstraction of a connection over raw UDP-like transport)
pub struct NetcodeConfig {
    pub num_disconnect_packets: usize,
    pub keepalive_packet_send_rate: f64,
    /// Set the duration (in seconds) after which the server disconnects a client if they don't hear from them.
    /// This is valid for tokens generated by the server.
    /// The default is 3 seconds. A negative value means no timeout.
    /// This is used when the client generates a `ConnectToken` (with `Authentication::Manual`)
    pub client_timeout_secs: i32,
    /// Set the duration in seconds after which the `ConnectToken` generated by the Client
    /// will expire. Set a negative value for the token to never expire.
    pub token_expire_secs: i32,
}

impl Default for NetcodeConfig {
    fn default() -> Self {
        Self {
            num_disconnect_packets: 10,
            keepalive_packet_send_rate: 1.0 / 10.0,
            client_timeout_secs: 3,
            token_expire_secs: 30,
        }
    }
}

impl NetcodeConfig {
    pub(crate) fn build(&self) -> ClientConfig<()> {
        ClientConfig::default()
            .num_disconnect_packets(self.num_disconnect_packets)
            .packet_send_rate(self.keepalive_packet_send_rate)
    }
}

impl NetcodeClient {
    pub fn new(auth: Authentication, config: NetcodeConfig) -> Result<Self, Error> {
        let token = auth
                    .get_token(config.client_timeout_secs, config.token_expire_secs)?;
        let token_bytes = token.try_into_bytes()?;
        Ok(Self {
            inner: crate::client::NetcodeClient::with_config(&token_bytes, config.build())?,
        })
    }

    pub fn id(&self) -> PeerId {
        PeerId::Netcode(self.inner.id())
    }
}

// TODO: when Client is spawned, add an observer for connection/disconnection, etc.

// TODO: set the remote_addr on the Link upon connection?

// We process bytes from the link and re-add them to the link so that the Transport can still
// fetch directly from the link
impl NetcodeClientPlugin {
    /// Takes packets from the Link, process them through netcode
    /// and buffer them back into the link to be sent by the IO
    fn send(
        mut query: Query<(&mut Link, &mut NetcodeClient)>,
    ) {
        query.par_iter_mut().for_each(|(mut link, mut client)| {
            // send user packets
            for _ in 0..link.send.len() {
                if let Some(payload) = link.send.pop() {
                    client.inner.send(payload, &mut link.send).inspect_err(|e| {
                        error!("Error sending packet: {:?}", e);
                    }).ok();
                }
            }

            // send netcode internal packets
            client.inner.send_netcode_packets(&mut link.send);
        })
    }

    /// Receive packets from the Link, and process them through the client,
    /// then buffer them back into the Link
    fn receive(
        real_time: Res<Time<Real>>,
        mut query: Query<(Entity, &mut Link, &mut NetcodeClient, Has<Connecting>)>,
        parallel_commands: ParallelCommands
    ) {
        let delta = real_time.delta();
        query.par_iter_mut().for_each(|(entity, mut link, mut client, connecting )| {
            // Buffer the packets received from the link into the Connection
            // don't short-circuit on error
            if let Some(state) = client.inner.try_update(delta.as_secs_f64(), &mut link.recv)
                .inspect_err(|e| {
                    error!("Error receiving packet: {:?}", e);
                })
                .ok() {

                if state == ClientState::Connected && connecting {
                    info!("Client {} connected", client.id());
                    parallel_commands.command_scope(|mut commands| {
                        commands.entity(entity).insert(Connected).remove::<Connecting>();
                    });
                }
            }
        })
    }

    fn connect(
        trigger: Trigger<Connect>,
        mut commands: Commands,
        mut query: Query<&mut NetcodeClient>,
    ) {
        if let Ok(mut client) = query.get_mut(trigger.target()) {
            debug!("Starting netcode connection process");
            client.inner.connect();
            commands.entity(trigger.target()).insert(Connecting);
        }
    }
    fn disconnect(
        trigger: Trigger<Disconnect>,
        mut commands: Commands,
        mut query: Query<(&mut NetcodeClient, &mut Link)>,
    ) -> Result {

        if let Ok((mut client, mut link)) = query.get_mut(trigger.target()) {
            client.inner.disconnect(&mut link.send)?;
            commands.entity(trigger.target()).insert(Disconnected);
        }
        Ok(())
    }
}


impl Plugin for NetcodeClientPlugin {
    fn build(&self, app: &mut App) {
        app.configure_sets(PreUpdate, (LinkSet::Receive, ConnectionSet::Receive,  TransportSet::Receive).chain());
        app.configure_sets(PostUpdate, (TransportSet::Send, ConnectionSet::Send, LinkSet::Send));

        app.add_systems(PreUpdate, Self::receive.in_set(ConnectionSet::Receive));
        app.add_systems(PostUpdate, Self::send.in_set(ConnectionSet::Send));
        app.add_observer(Self::connect);
        app.add_observer(Self::disconnect);
    }
}
