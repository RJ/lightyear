use crate::{ClientId, Key, NetcodeClient, ServerConfig, PRIVATE_KEY_BYTES};
use alloc::rc::Rc;
use alloc::sync::Arc;
use bevy::ecs::entity::unique_slice::UniqueEntitySlice;
use bevy::prelude::*;
use bevy::tasks::futures_lite::StreamExt;
use core::net::SocketAddr;
use lightyear_connection::client::{Connected, Connecting};
use lightyear_connection::prelude::{server::*, *};
use lightyear_link::{Link, LinkSet, LinkStart, Unlink, Unlinked};
use lightyear_transport::plugin::TransportSet;
use lightyear_transport::prelude::Transport;
use tracing::{error, info};

pub struct NetcodeServerPlugin;

#[derive(Default)]
pub(crate) struct NetcodeServerContext {
    pub(crate) connections: Vec<(ClientId, SocketAddr)>,
    pub(crate) disconnections: Vec<(ClientId, SocketAddr)>,
}

#[derive(Component)]
pub struct NetcodeServer {
    pub inner: crate::server::Server<NetcodeServerContext>
}


#[derive(Debug, Clone)]
pub struct NetcodeConfig {
    pub num_disconnect_packets: usize,
    pub keep_alive_send_rate: f64,
    /// Set the duration (in seconds) after which the server disconnects a client if they don't hear from them.
    /// This is valid for tokens generated by the server.
    /// The default is 3 seconds. A negative value means no timeout.
    pub client_timeout_secs: i32,
    pub protocol_id: u64,
    pub private_key: Key,
}

impl Default for NetcodeConfig {
    fn default() -> Self {
        Self {
            num_disconnect_packets: 10,
            keep_alive_send_rate: 1.0 / 10.0,
            client_timeout_secs: 3,
            protocol_id: 0,
            private_key: [0; PRIVATE_KEY_BYTES],
        }
    }
}

impl NetcodeConfig {
    pub fn with_protocol_id(mut self, protocol_id: u64) -> Self {
        self.protocol_id = protocol_id;
        self
    }
    pub fn with_key(mut self, key: Key) -> Self {
        self.private_key = key;
        self
    }

    pub fn with_client_timeout_secs(mut self, client_timeout_secs: i32) -> Self {
        self.client_timeout_secs = client_timeout_secs;
        self
    }
}

impl NetcodeServer {
    pub fn new(config: NetcodeConfig) -> Self {
        let context = NetcodeServerContext::default();
        let mut cfg = ServerConfig::with_context(context)
            .on_connect(|id, addr, ctx| {
                ctx.connections.push((id, addr));
            })
            .on_disconnect(|id, addr, ctx| {
                ctx.disconnections.push((id, addr));
            });
        cfg = cfg.keep_alive_send_rate(config.keep_alive_send_rate);
        cfg = cfg.num_disconnect_packets(config.num_disconnect_packets);
        cfg = cfg.client_timeout_secs(config.client_timeout_secs);
        let server = crate::server::Server::with_config(config.protocol_id, config.private_key, cfg)
            .expect("Could not create server netcode");
        Self {
            inner: server
        }
    }
}


impl NetcodeServerPlugin {

    /// Takes packets from the Link, process them through the server,
    /// and buffer them back into the link to be sent by the IO
    fn send(
        mut server_query: Query<(&mut NetcodeServer, &Server), Without<Stopped>>,
        // TODO: I don't like how we expect even non connected clients to have ClientOf
        client_query: Query<(&mut Link, &ClientOf)>,
    ) {
        // TODO: we should be able to do ParIterMut if we can make the code understand
        //  that the transports/links are all mutually exclusive...
        //  Maybe some unsafe Cloneble wrapper around the client_query?
        //  Or maybe store the clients into a Local<Vec<(&mut Transport, &mut Link)>>? so that we can iterate faster through them?
        // we use Arc to tell the compiler that we know that the queries won't be used to access
        // the same clients (because each Link is uniquely associated with a single server)
        // This allow us to iterate in parallel over all servers
        let client_query = Arc::new(client_query);
        server_query.par_iter_mut().for_each(|(mut netcode_server, server)| {
            // SAFETY: we know that each client is unique to a single server so we won't
            //  violate aliasing rules
            let mut client_query = unsafe { client_query.reborrow_unsafe() };

            // SAFETY: we know that the entities of a relationship are unique
            let unique_slice = unsafe { UniqueEntitySlice::from_slice_unchecked(server.collection()) };
            client_query.iter_many_unique_mut(unique_slice).for_each(|(mut link, client_of)|  {

                // TODO: we can be here while the link has been established, but the client is not yet connected
                //  so the PeerId is not Netcode! I think we should just error?

                // If the client was connected, it has a Netcode client_id
                if let PeerId::Netcode(client_id) = client_of.id  {
                    for _ in 0..link.send.len() {
                        if let Some(payload) = link.send.pop() {
                            netcode_server.inner.send(payload, client_id, &mut link.send).inspect_err(|e| {
                                error!("Error sending packet: {:?}", e);
                            }).ok();
                        }
                    }

                    // NOTE: we send any netcode packets AFTER the user payloads have been processed
                    netcode_server.inner.send_keepalives(client_id, &mut link.send);
                };

                // even if it was not connected, we might need to send the netcode packets that were buffered
                let Some(addr) = link.remote_addr else {
                    error!("Link used with netcode has no remote address");
                    return;
                };
                netcode_server.inner.send_netcode_packets(addr, &mut link.send);
            });
        })
    }

    /// Receive packets from the Link, process them through the server,
    /// then buffer them back into the Link
    fn receive(
        parallel_commands: ParallelCommands,
        real_time: Res<Time<Real>>,
        mut server_query: Query<(&mut NetcodeServer, &mut Server), Without<Stopped>>,
        link_query: Query<(Entity, &mut Link, &mut ClientOf)>,
    ) {
        let delta = real_time.delta();

        // we use Arc to tell the compiler that we know that the queries won't be used to access
        // the same clients (because each Link is uniquely associated with a single server)
        // This allow us to iterate in parallel over all servers
        let mut link_query = Arc::new(link_query);

        // receive packets from the link and process them through the server
        server_query.par_iter_mut().for_each(|(mut netcode_server, mut server)| {
            // SAFETY: we know that each client is unique to a single server so we won't
            //  violate aliasing rules
            let mut link_query = unsafe { link_query.reborrow_unsafe() };

            netcode_server.inner.update_state(delta.as_secs_f64());

            // TODO: try to make this parallel!

            // enable split borrows
            let server = &mut *server;
            // SAFETY: we know that the list of client entities are unique because it is a Relationship
            let unique_slice = unsafe { UniqueEntitySlice::from_slice_unchecked(&server.clients) };
            link_query.iter_many_unique_mut(unique_slice).for_each(|(entity, mut link, mut client_of)| {
                 match netcode_server.inner.receive(link.as_mut()) {
                     Ok(errors) => {
                         for error in errors {
                             error!("Error receiving packet: {:?}", error);
                         }
                     }
                    Err(e) => {
                        error!("Error receiving packet: {:?}", e);
                    }
                 }

                // Connections: we know the connection comes from the current entity!
                netcode_server.inner.cfg.context.connections.drain(..).for_each(|(id, addr)| {
                    // TODO: mention server id in case we have multiple servers
                    info!("New connection on netcode from {:?} ({:?})", id, addr);
                    server.client_map.insert(PeerId::Netcode(id), entity);
                    parallel_commands.command_scope(|mut c| {
                        c.entity(entity).insert(Connected).remove::<Connecting>();
                    })
                });

                // Disconnections: we know the disconnection comes from the current entity!
                netcode_server.inner.cfg.context.connections.drain(..).for_each(|(id, addr)| {
                    // TODO: mention server id in case we have multiple servers
                    info!("Disconnection from netcode client {:?}", id);
                    parallel_commands.command_scope(|mut c| {
                        c.entity(entity).despawn();
                        // disconnect or just despawn?
                        // c.entity(entity).remove::<Connected>().insert::<Disconnecting>();
                    })
                })
            });
        })
    }

    fn start(
        trigger: Trigger<Start>,
        mut commands: Commands,
    ) {
        commands.trigger_targets(LinkStart, trigger.target());
        commands.entity(trigger.target()).remove::<Stopped>().insert(Started);
    }

    fn stop(
        trigger: Trigger<Stop>,
        mut commands: Commands,
        mut query: Query<(Entity, &mut NetcodeServer, &Server)>,
        mut link_query: Query<(&mut Link, &ClientOf)>,
    ) -> Result {
        if let Ok((entity, mut netcode_server, server)) = query.get_mut(trigger.target()) {
            // stop the ServerIo that is on this entity (for example webtransport server)
            commands.trigger_targets(Unlink, entity);

            // SAFETY: we know that the list of client entities are unique because it is a Relationship
            let unique_slice = unsafe { UniqueEntitySlice::from_slice_unchecked(&server.clients) };
            link_query.iter_many_unique_mut(unique_slice).try_for_each(|(mut link, client_of)| {
                let PeerId::Netcode(client_id) = client_of.id else {
                    error!("Client {:?} is not a Netcode client", client_of.id);
                    return Err(crate::error::Error::UnknownClient(client_of.id));
                };
                netcode_server.inner.disconnect(client_id, &mut link.send)?;
                Ok(())
                // TODO: mark each client as Disconnecting. (we want to give them time) to send the disconnect packets
                //  at the end of the frame
                //  then despawn all the client entities!
            });
        }
        Ok(())
    }
}



impl Plugin for NetcodeServerPlugin {
    fn build(&self, app: &mut App) {
        // TODO: should these be shared? or do we use Markers like in lightyear to distinguish between client and server?
        app.configure_sets(PreUpdate, (LinkSet::Receive, ConnectionSet::Receive, TransportSet::Receive).chain());
        app.configure_sets(PostUpdate, (TransportSet::Send, ConnectionSet::Send, LinkSet::Send));

        app.add_systems(PreUpdate, Self::receive.in_set(ConnectionSet::Receive));
        app.add_systems(PostUpdate, Self::send.in_set(ConnectionSet::Send));

        app.add_observer(Self::start);
        app.add_observer(Self::stop);
    }
}
