use crate::{ClientId, Key, NetcodeClient, ServerConfig, PRIVATE_KEY_BYTES};
use alloc::rc::Rc;
use alloc::sync::Arc;
use bevy::ecs::entity::unique_slice::UniqueEntitySlice;
use bevy::prelude::*;
use bevy::tasks::futures_lite::StreamExt;
use core::net::SocketAddr;
use lightyear_connection::client::{Connected, Connecting};
use lightyear_connection::prelude::{server::*, *};
use lightyear_link::{Link, LinkSet};
use lightyear_transport::plugin::TransportSet;
use lightyear_transport::prelude::Transport;
use tracing::{error, info};

pub struct NetcodeServerPlugin;

#[derive(Default)]
pub(crate) struct NetcodeServerContext {
    pub(crate) connections: Vec<(ClientId, SocketAddr)>,
    pub(crate) disconnections: Vec<(ClientId, SocketAddr)>,
}

#[derive(Component)]
pub struct NetcodeServer {
    pub inner: crate::server::NetcodeServer<NetcodeServerContext>
}


#[derive(Debug, Clone)]
pub struct NetcodeConfig {
    pub num_disconnect_packets: usize,
    pub keep_alive_send_rate: f64,
    /// Set the duration (in seconds) after which the server disconnects a client if they don't hear from them.
    /// This is valid for tokens generated by the server.
    /// The default is 3 seconds. A negative value means no timeout.
    pub client_timeout_secs: i32,
    pub protocol_id: u64,
    pub private_key: Key,
}

impl Default for NetcodeConfig {
    fn default() -> Self {
        Self {
            num_disconnect_packets: 10,
            keep_alive_send_rate: 1.0 / 10.0,
            client_timeout_secs: 3,
            protocol_id: 0,
            private_key: [0; PRIVATE_KEY_BYTES],
        }
    }
}

impl NetcodeConfig {
    pub fn with_protocol_id(mut self, protocol_id: u64) -> Self {
        self.protocol_id = protocol_id;
        self
    }
    pub fn with_key(mut self, key: Key) -> Self {
        self.private_key = key;
        self
    }

    pub fn with_client_timeout_secs(mut self, client_timeout_secs: i32) -> Self {
        self.client_timeout_secs = client_timeout_secs;
        self
    }
}

impl NetcodeServer {
    pub fn new(config: NetcodeConfig) -> Self {
        let context = NetcodeServerContext::default();
        let mut cfg = ServerConfig::with_context(context)
            .on_connect(|id, addr, ctx| {
                ctx.connections.push((id, addr));
            })
            .on_disconnect(|id, addr, ctx| {
                ctx.disconnections.push((id, addr));
            });
        cfg = cfg.keep_alive_send_rate(config.keep_alive_send_rate);
        cfg = cfg.num_disconnect_packets(config.num_disconnect_packets);
        cfg = cfg.client_timeout_secs(config.client_timeout_secs);
        let server = crate::server::NetcodeServer::with_config(config.protocol_id, config.private_key, cfg)
            .expect("Could not create server netcode");
        Self {
            inner: server
        }
    }
}


impl NetcodeServerPlugin {

    /// Takes packets from the Link, process them through the server,
    /// and buffer them back into the link to be sent by the IO
    fn send(
        mut server_query: Query<(&mut NetcodeServer, &Server), Without<Stopped>>,
        client_query: Query<(&mut Link, &ClientOf)>,
    ) {
        // TODO: we should be able to do ParIterMut if we can make the code understand
        //  that the transports/links are all mutually exclusive...
        //  Maybe some unsafe Cloneble wrapper around the client_query?
        //  Or maybe store the clients into a Local<Vec<(&mut Transport, &mut Link)>>? so that we can iterate faster through them?
        // we use Arc to tell the compiler that we know that the queries won't be used to access
        // the same clients (because each Link is uniquely associated with a single server)
        // This allow us to iterate in parallel over all servers
        let client_query = Arc::new(client_query);
        server_query.par_iter_mut().for_each(|(mut netcode_server, server)| {
            // SAFETY: we know that each client is unique to a single server so we won't
            //  violate aliasing rules
            let mut client_query = unsafe { client_query.reborrow_unsafe() };

            // SAFETY: we know that the entities of a relationship are unique
            let unique_slice = unsafe { UniqueEntitySlice::from_slice_unchecked(server.collection()) };
            client_query.iter_many_unique_mut(unique_slice).for_each(|(mut link, client_of)|  {
                 let PeerId::Netcode(client_id) = client_of.id else {
                    error!("Client {:?} is not a Netcode client", client_of.id);
                    return
                };

                while let Some(payload) = link.send.pop() {
                    netcode_server.inner.send(payload, client_id, &mut link.send).inspect_err(|e| {
                        error!("Error sending packet: {:?}", e);
                    }).ok();
                }
                // link.send.drain(..).try_for_each(|payload| {
                //     netcode_server.inner.buffer_send(payload, client_id)
                // }).inspect_err(|e| {
                //     error!("Error sending packet: {:?}", e);
                // }).ok();
                //
                // // we don't want to short-circuit on error
                // netcode_server.inner.send_buffered(link.send.as_mut()).inspect_err(|e| {
                //     error!("Error sending packet: {:?}", e);
                // }).ok();
            });
        })
    }

    /// Receive packets from the Link, process them through the server,
    /// then buffer them back into the Link
    fn receive(
        parallel_commands: ParallelCommands,
        real_time: Res<Time<Real>>,
        mut server_query: Query<(&mut NetcodeServer, &mut Server), Without<Stopped>>,
        link_query: Query<(Entity, &mut Link, &mut ClientOf)>,
    ) {
        let delta = real_time.delta();

        // we use Arc to tell the compiler that we know that the queries won't be used to access
        // the same clients (because each Link is uniquely associated with a single server)
        // This allow us to iterate in parallel over all servers
        let mut link_query = Arc::new(link_query);
        server_query.par_iter_mut().for_each(|(mut netcode_server, mut server)| {
            // SAFETY: we know that each client is unique to a single server so we won't
            //  violate aliasing rules
            let mut link_query = unsafe { link_query.reborrow_unsafe() };

            // receive packets from the link and process them through the server
            netcode_server.inner.update_state(delta.as_secs_f64());

            // TODO: try to make this parallel!

            // enable split borrows
            let server = &mut *server;
            // SAFETY: we know that the list of client entities are unique because it is a Relationship
            let unique_slice = unsafe { UniqueEntitySlice::from_slice_unchecked(&server.clients) };
            link_query.iter_many_unique_mut(unique_slice).for_each(|(entity, mut link, mut client_of)| {
                 netcode_server.inner.receive(link.as_mut()).inspect_err(|e| {
                    error!("Error receiving packets: {:?}", e);
                 }).ok();

                // Connections: we know the connection comes from the current entity!
                netcode_server.inner.cfg.context.connections.drain(..).for_each(|(id, addr)| {
                    // TODO: mention server id in case we have multiple servers
                    info!("New connection on netcode from {:?} ({:?})", id, addr);
                    server.client_map.insert(PeerId::Netcode(id), entity);
                    parallel_commands.command_scope(|mut c| {
                        c.entity(entity).insert(Connected).remove::<Connecting>();
                    })
                });

                // Disconnections: we know the disconnection comes from the current entity!
                netcode_server.inner.cfg.context.connections.drain(..).for_each(|(id, addr)| {
                    // TODO: mention server id in case we have multiple servers
                    info!("Disconnection from netcode client {:?}", id);
                    parallel_commands.command_scope(|mut c| {
                        c.entity(entity).despawn();
                        // disconnect or just despawn?
                        // c.entity(entity).remove::<Connected>().insert::<Disconnecting>();
                    })
                })
            });
        })
    }
}


impl Plugin for NetcodeServerPlugin {
    fn build(&self, app: &mut App) {
        // TODO: should these be shared? or do we use Markers like in lightyear to distinguish between client and server?
        app.configure_sets(PreUpdate, (LinkSet::Receive, ConnectionSet::Receive, TransportSet::Receive).chain());
        app.configure_sets(PostUpdate, (TransportSet::Send, ConnectionSet::Send, LinkSet::Send));

        app.add_systems(PreUpdate, Self::receive.in_set(ConnectionSet::Receive));
        app.add_systems(PostUpdate, Self::send.in_set(ConnectionSet::Send));
    }
}